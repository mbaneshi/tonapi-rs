/*
 * REST api to TON blockchain explorer
 *
 * Provide access to indexed TON blockchain
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@tonkeeper.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`account_dns_back_resolve`]
#[derive(Clone, Debug)]
pub struct AccountDnsBackResolveParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`address_parse`]
#[derive(Clone, Debug)]
pub struct AddressParseParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`get_account`]
#[derive(Clone, Debug)]
pub struct GetAccountParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`get_account_diff`]
#[derive(Clone, Debug)]
pub struct GetAccountDiffParams {
    /// account ID
    pub account_id: String,
    pub start_date: i64,
    pub end_date: i64
}

/// struct for passing parameters to the method [`get_account_dns_expiring`]
#[derive(Clone, Debug)]
pub struct GetAccountDnsExpiringParams {
    /// account ID
    pub account_id: String,
    /// number of days before expiration
    pub period: Option<i32>
}

/// struct for passing parameters to the method [`get_account_event`]
#[derive(Clone, Debug)]
pub struct GetAccountEventParams {
    /// account ID
    pub account_id: String,
    /// event ID or transaction hash in hex (without 0x) or base64url format
    pub event_id: String,
    pub accept_language: Option<String>,
    /// filter actions where requested account is not real subject (for example sender or receiver jettons)
    pub subject_only: Option<bool>
}

/// struct for passing parameters to the method [`get_account_events`]
#[derive(Clone, Debug)]
pub struct GetAccountEventsParams {
    /// account ID
    pub account_id: String,
    pub limit: i32,
    pub accept_language: Option<String>,
    /// Show only events that are initiated by this account
    pub initiator: Option<bool>,
    /// filter actions where requested account is not real subject (for example sender or receiver jettons)
    pub subject_only: Option<bool>,
    /// omit this parameter to get last events
    pub before_lt: Option<i64>,
    pub start_date: Option<i64>,
    pub end_date: Option<i64>
}

/// struct for passing parameters to the method [`get_account_jetton_history_by_id`]
#[derive(Clone, Debug)]
pub struct GetAccountJettonHistoryByIdParams {
    /// account ID
    pub account_id: String,
    /// jetton ID
    pub jetton_id: String,
    pub limit: i32,
    pub accept_language: Option<String>,
    /// omit this parameter to get last events
    pub before_lt: Option<i64>,
    pub start_date: Option<i64>,
    pub end_date: Option<i64>
}

/// struct for passing parameters to the method [`get_account_jettons_balances`]
#[derive(Clone, Debug)]
pub struct GetAccountJettonsBalancesParams {
    /// account ID
    pub account_id: String,
    /// accept ton and all possible fiat currencies, separated by commas
    pub currencies: Option<String>
}

/// struct for passing parameters to the method [`get_account_jettons_history`]
#[derive(Clone, Debug)]
pub struct GetAccountJettonsHistoryParams {
    /// account ID
    pub account_id: String,
    pub limit: i32,
    pub accept_language: Option<String>,
    /// omit this parameter to get last events
    pub before_lt: Option<i64>,
    pub start_date: Option<i64>,
    pub end_date: Option<i64>
}

/// struct for passing parameters to the method [`get_account_nft_items`]
#[derive(Clone, Debug)]
pub struct GetAccountNftItemsParams {
    /// account ID
    pub account_id: String,
    /// nft collection
    pub collection: Option<String>,
    pub limit: Option<i32>,
    pub offset: Option<i32>,
    /// Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly.
    pub indirect_ownership: Option<bool>
}

/// struct for passing parameters to the method [`get_account_public_key`]
#[derive(Clone, Debug)]
pub struct GetAccountPublicKeyParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`get_account_subscriptions`]
#[derive(Clone, Debug)]
pub struct GetAccountSubscriptionsParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`get_account_traces`]
#[derive(Clone, Debug)]
pub struct GetAccountTracesParams {
    /// account ID
    pub account_id: String,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_accounts`]
#[derive(Clone, Debug)]
pub struct GetAccountsParams {
    /// a list of account ids
    pub get_accounts_request: Option<crate::models::GetAccountsRequest>
}

/// struct for passing parameters to the method [`reindex_account`]
#[derive(Clone, Debug)]
pub struct ReindexAccountParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`search_accounts`]
#[derive(Clone, Debug)]
pub struct SearchAccountsParams {
    pub name: String
}


/// struct for typed errors of method [`account_dns_back_resolve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountDnsBackResolveError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`address_parse`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressParseError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_diff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountDiffError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_dns_expiring`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountDnsExpiringError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountEventError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountEventsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_jetton_history_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountJettonHistoryByIdError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_jettons_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountJettonsBalancesError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_jettons_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountJettonsHistoryError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_nft_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountNftItemsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountPublicKeyError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountSubscriptionsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_traces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountTracesError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reindex_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReindexAccountError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAccountsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}


/// Get account's domains
pub async fn account_dns_back_resolve(configuration: &configuration::Configuration, params: AccountDnsBackResolveParams) -> Result<crate::models::DomainNames, Error<AccountDnsBackResolveError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/dns/backresolve", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AccountDnsBackResolveError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// parse address and display in all formats
pub async fn address_parse(configuration: &configuration::Configuration, params: AddressParseParams) -> Result<crate::models::AddressParse200Response, Error<AddressParseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/address/{account_id}/parse", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddressParseError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get human-friendly information about an account without low-level details.
pub async fn get_account(configuration: &configuration::Configuration, params: GetAccountParams) -> Result<crate::models::Account, Error<GetAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get account's balance change
pub async fn get_account_diff(configuration: &configuration::Configuration, params: GetAccountDiffParams) -> Result<crate::models::GetAccountDiff200Response, Error<GetAccountDiffError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let start_date = params.start_date;
    let end_date = params.end_date;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/diff", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("start_date", &start_date.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("end_date", &end_date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountDiffError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get expiring account .ton dns
pub async fn get_account_dns_expiring(configuration: &configuration::Configuration, params: GetAccountDnsExpiringParams) -> Result<crate::models::DnsExpiring, Error<GetAccountDnsExpiringError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let period = params.period;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/dns/expiring", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = period {
        local_var_req_builder = local_var_req_builder.query(&[("period", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountDnsExpiringError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get event for an account by event_id
pub async fn get_account_event(configuration: &configuration::Configuration, params: GetAccountEventParams) -> Result<crate::models::AccountEvent, Error<GetAccountEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let event_id = params.event_id;
    let accept_language = params.accept_language;
    let subject_only = params.subject_only;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/events/{event_id}", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id), event_id=crate::apis::urlencode(event_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = subject_only {
        local_var_req_builder = local_var_req_builder.query(&[("subject_only", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = accept_language {
        local_var_req_builder = local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountEventError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
pub async fn get_account_events(configuration: &configuration::Configuration, params: GetAccountEventsParams) -> Result<crate::models::AccountEvents, Error<GetAccountEventsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let limit = params.limit;
    let accept_language = params.accept_language;
    let initiator = params.initiator;
    let subject_only = params.subject_only;
    let before_lt = params.before_lt;
    let start_date = params.start_date;
    let end_date = params.end_date;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/events", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = initiator {
        local_var_req_builder = local_var_req_builder.query(&[("initiator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = subject_only {
        local_var_req_builder = local_var_req_builder.query(&[("subject_only", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before_lt {
        local_var_req_builder = local_var_req_builder.query(&[("before_lt", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("limit", &limit.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = accept_language {
        local_var_req_builder = local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountEventsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the transfer jetton history for account and jetton
pub async fn get_account_jetton_history_by_id(configuration: &configuration::Configuration, params: GetAccountJettonHistoryByIdParams) -> Result<crate::models::AccountEvents, Error<GetAccountJettonHistoryByIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let jetton_id = params.jetton_id;
    let limit = params.limit;
    let accept_language = params.accept_language;
    let before_lt = params.before_lt;
    let start_date = params.start_date;
    let end_date = params.end_date;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/jettons/{jetton_id}/history", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id), jetton_id=crate::apis::urlencode(jetton_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = before_lt {
        local_var_req_builder = local_var_req_builder.query(&[("before_lt", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("limit", &limit.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = accept_language {
        local_var_req_builder = local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountJettonHistoryByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all Jettons balances by owner address
pub async fn get_account_jettons_balances(configuration: &configuration::Configuration, params: GetAccountJettonsBalancesParams) -> Result<crate::models::JettonsBalances, Error<GetAccountJettonsBalancesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let currencies = params.currencies;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/jettons", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = currencies {
        local_var_req_builder = local_var_req_builder.query(&[("currencies", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountJettonsBalancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the transfer jettons history for account
pub async fn get_account_jettons_history(configuration: &configuration::Configuration, params: GetAccountJettonsHistoryParams) -> Result<crate::models::AccountEvents, Error<GetAccountJettonsHistoryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let limit = params.limit;
    let accept_language = params.accept_language;
    let before_lt = params.before_lt;
    let start_date = params.start_date;
    let end_date = params.end_date;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/jettons/history", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = before_lt {
        local_var_req_builder = local_var_req_builder.query(&[("before_lt", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("limit", &limit.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = accept_language {
        local_var_req_builder = local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountJettonsHistoryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all NFT items by owner address
pub async fn get_account_nft_items(configuration: &configuration::Configuration, params: GetAccountNftItemsParams) -> Result<crate::models::NftItems, Error<GetAccountNftItemsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let collection = params.collection;
    let limit = params.limit;
    let offset = params.offset;
    let indirect_ownership = params.indirect_ownership;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/nfts", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = collection {
        local_var_req_builder = local_var_req_builder.query(&[("collection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = indirect_ownership {
        local_var_req_builder = local_var_req_builder.query(&[("indirect_ownership", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountNftItemsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get public key by account id
pub async fn get_account_public_key(configuration: &configuration::Configuration, params: GetAccountPublicKeyParams) -> Result<crate::models::GetAccountPublicKey200Response, Error<GetAccountPublicKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/publickey", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountPublicKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all subscriptions by wallet address
pub async fn get_account_subscriptions(configuration: &configuration::Configuration, params: GetAccountSubscriptionsParams) -> Result<crate::models::Subscriptions, Error<GetAccountSubscriptionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/subscriptions", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountSubscriptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get traces for account
pub async fn get_account_traces(configuration: &configuration::Configuration, params: GetAccountTracesParams) -> Result<crate::models::TraceIds, Error<GetAccountTracesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/traces", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountTracesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get human-friendly information about several accounts without low-level details.
pub async fn get_accounts(configuration: &configuration::Configuration, params: GetAccountsParams) -> Result<crate::models::Accounts, Error<GetAccountsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let get_accounts_request = params.get_accounts_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/_bulk", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&get_accounts_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update internal cache for a particular account
pub async fn reindex_account(configuration: &configuration::Configuration, params: ReindexAccountParams) -> Result<(), Error<ReindexAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account_id}/reindex", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ReindexAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search by account domain name
pub async fn search_accounts(configuration: &configuration::Configuration, params: SearchAccountsParams) -> Result<crate::models::FoundAccounts, Error<SearchAccountsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("name", &name.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SearchAccountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

