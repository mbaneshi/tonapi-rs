use serde::{Deserialize, Serialize};

/*
 * REST api to TON blockchain explorer
 *
 * Provide access to indexed TON blockchain
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@tonkeeper.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use tonlib::address::TonAddress;

use super::{configuration, Error};
use crate::rest_api::codegen::apis::ResponseContent;

/// struct for passing parameters to the method [`get_account_nft_history`]
#[derive(Clone, Debug)]
pub struct GetAccountNftHistoryParams {
    /// account ID
    pub account_id: TonAddress,
    pub limit: i32,
    pub accept_language: Option<String>,
    /// omit this parameter to get last events
    pub before_lt: Option<i64>,
    pub start_date: Option<i64>,
    pub end_date: Option<i64>,
}

/// struct for passing parameters to the method [`get_items_from_collection`]
#[derive(Clone, Debug)]
pub struct GetItemsFromCollectionParams {
    /// account ID
    pub account_id: TonAddress,
    pub limit: Option<i32>,
    pub offset: Option<i32>,
}

/// struct for passing parameters to the method [`get_nft_collection`]
#[derive(Clone, Debug)]
pub struct GetNftCollectionParams {
    /// account ID
    pub account_id: TonAddress,
}

/// struct for passing parameters to the method [`get_nft_collections`]
#[derive(Clone, Debug)]
pub struct GetNftCollectionsParams {
    pub limit: Option<i32>,
    pub offset: Option<i32>,
}

/// struct for passing parameters to the method [`get_nft_history_by_id`]
#[derive(Clone, Debug)]
pub struct GetNftHistoryByIdParams {
    /// account ID
    pub account_id: TonAddress,
    pub limit: i32,
    pub accept_language: Option<String>,
    /// omit this parameter to get last events
    pub before_lt: Option<i64>,
    pub start_date: Option<i64>,
    pub end_date: Option<i64>,
}

/// struct for passing parameters to the method [`get_nft_item_by_address`]
#[derive(Clone, Debug)]
pub struct GetNftItemByAddressParams {
    /// account ID
    pub account_id: TonAddress,
}

/// struct for passing parameters to the method [`get_nft_items_by_addresses`]
#[derive(Clone, Debug)]
pub struct GetNftItemsByAddressesParams {
    /// a list of account ids
    pub get_accounts_request: Option<crate::rest_api::codegen::models::GetAccountsRequest>,
}

/// struct for typed errors of method [`get_account_nft_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountNftHistoryError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_items_from_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetItemsFromCollectionError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftCollectionError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftCollectionsError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_history_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftHistoryByIdError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_item_by_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftItemByAddressError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_items_by_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftItemsByAddressesError {
    DefaultResponse(crate::rest_api::codegen::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// Get the transfer nft history
pub async fn get_account_nft_history(
    configuration: &configuration::Configuration,
    params: GetAccountNftHistoryParams,
) -> Result<crate::rest_api::codegen::models::AccountEvents, Error<GetAccountNftHistoryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let limit = params.limit;
    let accept_language = params.accept_language;
    let before_lt = params.before_lt;
    let start_date = params.start_date;
    let end_date = params.end_date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}/nfts/history",
        local_var_configuration.base_path,
        account_id = crate::rest_api::codegen::apis::urlencode(account_id.to_base64_url())
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = before_lt {
        local_var_req_builder =
            local_var_req_builder.query(&[("before_lt", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("limit", &limit.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = accept_language {
        local_var_req_builder =
            local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAccountNftHistoryError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get NFT items from collection by collection address
pub async fn get_items_from_collection(
    configuration: &configuration::Configuration,
    params: GetItemsFromCollectionParams,
) -> Result<crate::rest_api::codegen::models::NftItems, Error<GetItemsFromCollectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let limit = params.limit;
    let offset = params.offset;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/nfts/collections/{account_id}/items",
        local_var_configuration.base_path,
        account_id = crate::rest_api::codegen::apis::urlencode(account_id.to_base64_url())
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetItemsFromCollectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get NFT collection by collection address
pub async fn get_nft_collection(
    configuration: &configuration::Configuration,
    params: GetNftCollectionParams,
) -> Result<crate::rest_api::codegen::models::NftCollection, Error<GetNftCollectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/nfts/collections/{account_id}",
        local_var_configuration.base_path,
        account_id = crate::rest_api::codegen::apis::urlencode(account_id.to_base64_url())
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNftCollectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get NFT collections
pub async fn get_nft_collections(
    configuration: &configuration::Configuration,
    params: GetNftCollectionsParams,
) -> Result<crate::rest_api::codegen::models::NftCollections, Error<GetNftCollectionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let offset = params.offset;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/nfts/collections", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNftCollectionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the transfer nfts history for account
pub async fn get_nft_history_by_id(
    configuration: &configuration::Configuration,
    params: GetNftHistoryByIdParams,
) -> Result<crate::rest_api::codegen::models::AccountEvents, Error<GetNftHistoryByIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let limit = params.limit;
    let accept_language = params.accept_language;
    let before_lt = params.before_lt;
    let start_date = params.start_date;
    let end_date = params.end_date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/nfts/{account_id}/history",
        local_var_configuration.base_path,
        account_id = crate::rest_api::codegen::apis::urlencode(account_id.to_base64_url())
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = before_lt {
        local_var_req_builder =
            local_var_req_builder.query(&[("before_lt", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("limit", &limit.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = accept_language {
        local_var_req_builder =
            local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNftHistoryByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get NFT item by its address
pub async fn get_nft_item_by_address(
    configuration: &configuration::Configuration,
    params: GetNftItemByAddressParams,
) -> Result<crate::rest_api::codegen::models::NftItem, Error<GetNftItemByAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/nfts/{account_id}",
        local_var_configuration.base_path,
        account_id = crate::rest_api::codegen::apis::urlencode(account_id.to_base64_url())
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNftItemByAddressError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get NFT items by their addresses
pub async fn get_nft_items_by_addresses(
    configuration: &configuration::Configuration,
    params: GetNftItemsByAddressesParams,
) -> Result<crate::rest_api::codegen::models::NftItems, Error<GetNftItemsByAddressesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let get_accounts_request = params.get_accounts_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/nfts/_bulk", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref bearer_access_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(bearer_access_token);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&get_accounts_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNftItemsByAddressesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
