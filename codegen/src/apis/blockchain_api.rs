/*
 * REST api to TON blockchain explorer
 *
 * Provide access to indexed TON blockchain
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@tonkeeper.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`blockchain_account_inspect`]
#[derive(Clone, Debug)]
pub struct BlockchainAccountInspectParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`exec_get_method_for_blockchain_account`]
#[derive(Clone, Debug)]
pub struct ExecGetMethodForBlockchainAccountParams {
    /// account ID
    pub account_id: String,
    /// contract get method name
    pub method_name: String,
    pub args: Option<Vec<String>>
}

/// struct for passing parameters to the method [`get_blockchain_account_transactions`]
#[derive(Clone, Debug)]
pub struct GetBlockchainAccountTransactionsParams {
    /// account ID
    pub account_id: String,
    /// omit this parameter to get last transactions
    pub after_lt: Option<i64>,
    /// omit this parameter to get last transactions
    pub before_lt: Option<i64>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_blockchain_block`]
#[derive(Clone, Debug)]
pub struct GetBlockchainBlockParams {
    /// block ID
    pub block_id: String
}

/// struct for passing parameters to the method [`get_blockchain_block_transactions`]
#[derive(Clone, Debug)]
pub struct GetBlockchainBlockTransactionsParams {
    /// block ID
    pub block_id: String
}

/// struct for passing parameters to the method [`get_blockchain_config_from_block`]
#[derive(Clone, Debug)]
pub struct GetBlockchainConfigFromBlockParams {
    /// masterchain block seqno
    pub masterchain_seqno: i32
}

/// struct for passing parameters to the method [`get_blockchain_masterchain_blocks`]
#[derive(Clone, Debug)]
pub struct GetBlockchainMasterchainBlocksParams {
    /// masterchain block seqno
    pub masterchain_seqno: i32
}

/// struct for passing parameters to the method [`get_blockchain_masterchain_shards`]
#[derive(Clone, Debug)]
pub struct GetBlockchainMasterchainShardsParams {
    /// masterchain block seqno
    pub masterchain_seqno: i32
}

/// struct for passing parameters to the method [`get_blockchain_masterchain_transactions`]
#[derive(Clone, Debug)]
pub struct GetBlockchainMasterchainTransactionsParams {
    /// masterchain block seqno
    pub masterchain_seqno: i32
}

/// struct for passing parameters to the method [`get_blockchain_raw_account`]
#[derive(Clone, Debug)]
pub struct GetBlockchainRawAccountParams {
    /// account ID
    pub account_id: String
}

/// struct for passing parameters to the method [`get_blockchain_transaction`]
#[derive(Clone, Debug)]
pub struct GetBlockchainTransactionParams {
    /// transaction ID
    pub transaction_id: String
}

/// struct for passing parameters to the method [`get_blockchain_transaction_by_message_hash`]
#[derive(Clone, Debug)]
pub struct GetBlockchainTransactionByMessageHashParams {
    /// message ID
    pub msg_id: String
}

/// struct for passing parameters to the method [`get_raw_blockchain_config_from_block`]
#[derive(Clone, Debug)]
pub struct GetRawBlockchainConfigFromBlockParams {
    /// masterchain block seqno
    pub masterchain_seqno: i32
}

/// struct for passing parameters to the method [`send_blockchain_message`]
#[derive(Clone, Debug)]
pub struct SendBlockchainMessageParams {
    /// both a single boc and a batch of boc serialized in base64 are accepted
    pub send_blockchain_message_request: crate::models::SendBlockchainMessageRequest
}


/// struct for typed errors of method [`blockchain_account_inspect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlockchainAccountInspectError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exec_get_method_for_blockchain_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecGetMethodForBlockchainAccountError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_account_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainAccountTransactionsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainBlockError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_block_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainBlockTransactionsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainConfigError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_config_from_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainConfigFromBlockError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_masterchain_blocks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainMasterchainBlocksError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_masterchain_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainMasterchainHeadError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_masterchain_shards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainMasterchainShardsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_masterchain_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainMasterchainTransactionsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_raw_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainRawAccountError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainTransactionError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_transaction_by_message_hash`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainTransactionByMessageHashError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blockchain_validators`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockchainValidatorsError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_raw_blockchain_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRawBlockchainConfigError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_raw_blockchain_config_from_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRawBlockchainConfigFromBlockError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_blockchain_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendBlockchainMessageError {
    DefaultResponse(crate::models::GetBlockchainBlockDefaultResponse),
    UnknownValue(serde_json::Value),
}


/// Blockchain account inspect
pub async fn blockchain_account_inspect(configuration: &configuration::Configuration, params: BlockchainAccountInspectParams) -> Result<crate::models::BlockchainAccountInspect, Error<BlockchainAccountInspectError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/accounts/{account_id}/inspect", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlockchainAccountInspectError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Execute get method for account
pub async fn exec_get_method_for_blockchain_account(configuration: &configuration::Configuration, params: ExecGetMethodForBlockchainAccountParams) -> Result<crate::models::MethodExecutionResult, Error<ExecGetMethodForBlockchainAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let method_name = params.method_name;
    let args = params.args;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/accounts/{account_id}/methods/{method_name}", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id), method_name=crate::apis::urlencode(method_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = args {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("args".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("args", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExecGetMethodForBlockchainAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get account transactions
pub async fn get_blockchain_account_transactions(configuration: &configuration::Configuration, params: GetBlockchainAccountTransactionsParams) -> Result<crate::models::Transactions, Error<GetBlockchainAccountTransactionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let after_lt = params.after_lt;
    let before_lt = params.before_lt;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/accounts/{account_id}/transactions", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = after_lt {
        local_var_req_builder = local_var_req_builder.query(&[("after_lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before_lt {
        local_var_req_builder = local_var_req_builder.query(&[("before_lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainAccountTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get blockchain block data
pub async fn get_blockchain_block(configuration: &configuration::Configuration, params: GetBlockchainBlockParams) -> Result<crate::models::BlockchainBlock, Error<GetBlockchainBlockError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let block_id = params.block_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/blocks/{block_id}", local_var_configuration.base_path, block_id=crate::apis::urlencode(block_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainBlockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get transactions from block
pub async fn get_blockchain_block_transactions(configuration: &configuration::Configuration, params: GetBlockchainBlockTransactionsParams) -> Result<crate::models::Transactions, Error<GetBlockchainBlockTransactionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let block_id = params.block_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/blocks/{block_id}/transactions", local_var_configuration.base_path, block_id=crate::apis::urlencode(block_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainBlockTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get blockchain config
pub async fn get_blockchain_config(configuration: &configuration::Configuration) -> Result<crate::models::BlockchainConfig, Error<GetBlockchainConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get blockchain config from a specific block, if present.
pub async fn get_blockchain_config_from_block(configuration: &configuration::Configuration, params: GetBlockchainConfigFromBlockParams) -> Result<crate::models::BlockchainConfig, Error<GetBlockchainConfigFromBlockError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let masterchain_seqno = params.masterchain_seqno;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/masterchain/{masterchain_seqno}/config", local_var_configuration.base_path, masterchain_seqno=masterchain_seqno);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainConfigFromBlockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all blocks in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain.  We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
pub async fn get_blockchain_masterchain_blocks(configuration: &configuration::Configuration, params: GetBlockchainMasterchainBlocksParams) -> Result<crate::models::BlockchainBlocks, Error<GetBlockchainMasterchainBlocksError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let masterchain_seqno = params.masterchain_seqno;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/masterchain/{masterchain_seqno}/blocks", local_var_configuration.base_path, masterchain_seqno=masterchain_seqno);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainMasterchainBlocksError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get last known masterchain block
pub async fn get_blockchain_masterchain_head(configuration: &configuration::Configuration) -> Result<crate::models::BlockchainBlock, Error<GetBlockchainMasterchainHeadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/masterchain-head", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainMasterchainHeadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get blockchain block shards
pub async fn get_blockchain_masterchain_shards(configuration: &configuration::Configuration, params: GetBlockchainMasterchainShardsParams) -> Result<crate::models::BlockchainBlockShards, Error<GetBlockchainMasterchainShardsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let masterchain_seqno = params.masterchain_seqno;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/masterchain/{masterchain_seqno}/shards", local_var_configuration.base_path, masterchain_seqno=masterchain_seqno);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainMasterchainShardsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all transactions in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain. We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
pub async fn get_blockchain_masterchain_transactions(configuration: &configuration::Configuration, params: GetBlockchainMasterchainTransactionsParams) -> Result<crate::models::Transactions, Error<GetBlockchainMasterchainTransactionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let masterchain_seqno = params.masterchain_seqno;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/masterchain/{masterchain_seqno}/transactions", local_var_configuration.base_path, masterchain_seqno=masterchain_seqno);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainMasterchainTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get low-level information about an account taken directly from the blockchain.
pub async fn get_blockchain_raw_account(configuration: &configuration::Configuration, params: GetBlockchainRawAccountParams) -> Result<crate::models::BlockchainRawAccount, Error<GetBlockchainRawAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/accounts/{account_id}", local_var_configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainRawAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get transaction data
pub async fn get_blockchain_transaction(configuration: &configuration::Configuration, params: GetBlockchainTransactionParams) -> Result<crate::models::Transaction, Error<GetBlockchainTransactionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let transaction_id = params.transaction_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/transactions/{transaction_id}", local_var_configuration.base_path, transaction_id=crate::apis::urlencode(transaction_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainTransactionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get transaction data by message hash
pub async fn get_blockchain_transaction_by_message_hash(configuration: &configuration::Configuration, params: GetBlockchainTransactionByMessageHashParams) -> Result<crate::models::Transaction, Error<GetBlockchainTransactionByMessageHashError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let msg_id = params.msg_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/messages/{msg_id}/transaction", local_var_configuration.base_path, msg_id=crate::apis::urlencode(msg_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainTransactionByMessageHashError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get blockchain validators
pub async fn get_blockchain_validators(configuration: &configuration::Configuration) -> Result<crate::models::Validators, Error<GetBlockchainValidatorsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/validators", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBlockchainValidatorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get raw blockchain config
pub async fn get_raw_blockchain_config(configuration: &configuration::Configuration) -> Result<crate::models::RawBlockchainConfig, Error<GetRawBlockchainConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/config/raw", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRawBlockchainConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get raw blockchain config from a specific block, if present.
pub async fn get_raw_blockchain_config_from_block(configuration: &configuration::Configuration, params: GetRawBlockchainConfigFromBlockParams) -> Result<crate::models::RawBlockchainConfig, Error<GetRawBlockchainConfigFromBlockError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let masterchain_seqno = params.masterchain_seqno;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/masterchain/{masterchain_seqno}/config/raw", local_var_configuration.base_path, masterchain_seqno=masterchain_seqno);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRawBlockchainConfigFromBlockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send message to blockchain
pub async fn send_blockchain_message(configuration: &configuration::Configuration, params: SendBlockchainMessageParams) -> Result<(), Error<SendBlockchainMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let send_blockchain_message_request = params.send_blockchain_message_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blockchain/message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&send_blockchain_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<SendBlockchainMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

